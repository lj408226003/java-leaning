## Vue学习笔记-高级



### 1.ajax框架：Axios

> xhr ==> XMLHttpRequest
>
> 这是Ajax的鼻祖，底层写法就会使用xhr来发送ajax请求，由于比较繁琐，所以后续有很多封装的框架，
>
> 比如jquery、axios(是promise风格)等，而jquery除了封装ajax他还封装了dom操作，
>
> 而dom操作有了Vue（它本身不支持ajax功能）后引入jquery就不合适了，有点臃肿，
>
> 所以我们选择axios作为ajax框架，并且他是promise风格，代码写起来也比较优雅。
>
> 
>
> Vue自己早期业开发过一个ajax框架：vue-resource，后来不用了改成全部使用 axios，具体这个见《vue-resource》章节。



### 2.脚手架配置解决跨域问题

> 什么是跨域？
>
> 当前访问的网站A的页面中，通过ajax请求其他网站B(只要协议、url、port任何一个不相同，就不算是一个网站)，这时候浏览器就会认为跨域了，
>
> 注意跨域不是不发送请求，而是A中的ajax访问B时，请求到了B，并且B已经正常响应给了A，但是打开A的发送ajax的浏览器认为收到的响应是跨域操作，所以不会解析，直接报错。

<img src="/Users/lij/markdownWorkspace/java-leaning/resources/image-20220604135927639.png" alt="image-20220604135927639" style="zoom:33%;" align="left"/>

> 解决跨域方式：
>
> ① cors方式：由后端开发将响应的头信息(Header)多增加一些特殊的响应头，浏览器看到后虽然是跨域，但是服务器说了可以给解析。
>
> ② jsonp方式：只能解决get请求的跨域，并且需要前端和后端一起配合使用，实际开发中很少应用。
>
> ③ 设置代理服务器：比如nginx，<font color="red">当然此处我们讲一下使用Vue-CLI脚手架的使用。</font>

> 注意：服务器互相访问不会存在跨域，只有浏览器本身才会有跨域问题，而服务器之间即不存在浏览器方式访问又不存在ajax，哪来的跨域。



#### ①开发环境代理服务器：devServer.proxy 

注意：运行脚手架 npm run serve服务后，她会默认占用8080端口。

> 配置vue.config.js文件：将代理服务器添加进去
>
> ```js
> module.exports = {
>     // 开启代理服务器（方式一）
>     devServer: {
>     	// 这里配置代理到的后端的服务ip:port，因为脚手架启动后默认是8080端口，而devServer.proxy又是Vue脚手架提供的功能，
>     	// 所以这个代理服务器当然也是8080端口了，而(方式一)是全部代理，
>     	// 即全部到8080端口的请求都会转发到5000端口，所以前端的所有http请求(ajax请求)只要是8080都会转发到这个规则，即5000端口
>       // 其实就是脚手架+这个代理等价与nginx的功能
>       // 但他区别于nginx的是，请求静态资源nginx需要配置前缀，而此处的代理规则是如果请求8080，而本地存在的问题件，将会直接返回而去代理到后端
>       // 所以[方式一]不太好，我们需要真正像nginx一样的功能
>       proxy: 'http://localhost:5000'
>     },
>     
>     // 开启代理服务器（方式二）：基本和nginx一样了
>     devServer: {
>       proxy: {
>         // 设置一个虚拟的请求前缀，这样请求http://localhost:8080/atguigu/list将会转发到localhost:5000/atguigu/list
>         // 但实际的请求是localhost:5000/list，所以转发前需要重写queryString部分，即删掉虚拟前缀，通过pathRewrite，当然其实也可以不写虚拟前缀
>         '/atguigu': {  
>           target: 'http://localhost:5000',
>             pathRewrite:{'^/atguigu':''},
>             // ws: true, //用于支持websocket
>           	// 用于控制请求头中的host值，默认值true，在5000这个服务获取host时，将会也是5000，false时后端获取host是真实的localhost:8080
>             // changeOrigin: true 
>         },
>         '/demo': {
>           target: 'http://localhost:5001',
>               pathRewrite:{'^/demo':''},
>           // ws: true, //用于支持websocket
>           // changeOrigin: true //用于控制请求头中的host值
>         }
>       }
>     }
> }
> ```



### 3.vue-resource

> 早期Vue 1.0版本使用vue-resource较多，Vue是以插件的形式使用vue-resource的，即Vue.use()来使用。
>
> ```js
> // 1.安装vue-resource
> npm -i vue-resource
> 
> // 2.修改main.js， 因为这里有new Vue，而插件都是在new Vue之前使用
> import App from './App.vue';
> 
> // 导入插件
> import vueResource from 'vue-resource';
> // 使用插件
> Vue.use(vueResource);
> 
> new Vue({
> ...
> })
>   
> // 3.使用，假设在Student.vue组件中使用,Vue.$http就是插件定义到Vue原型上的对象，它提供了get、post等方法
> this.$http.get();  // 他也是promise api风格
> ```
>
> 缺点：基本和axios一样的使用方式，只不过Vue官方不再维护了，交给了第三方团队维护且更新维护频率比较低，所以建议使用axios。



### 4.插槽\<slot>标签：用于组件标签内部

前边我们讲的组件标签都是这种形式\<Student />，就是没有标签体，而\<slot>插槽就是为了组件标签有标签体且标签体中添加标签时[传参]使用的。

形如：组件标签中增加一个img标签，只是这样写对于Vue是不能知道你要将img标签渲染到组件结构的哪个位置的，这就需要在组件中通过<slot>来占位，表示将img渲染到slot的位置。

> <Student>
>
> ​	<img src=""/>
>
> </Student>



分类：插槽slot共有3种类型

- 默认插槽
- 具名插槽
- 作用域插槽



> ① 默认插槽 ：就像上边说的一样，在组件内增加占位标签<slot>用于接收组件标签体中添加的html标签，举例如下：
>
> ```vue
> // 1.增加组件 Category.vue
> <template>
> 	<div class="category">
> 		<h3>{{title}}分类</h3>
> 		<!-- 定义一个插槽（占位，等着组件的使用者进行填充） -->
> 		<slot>我是一些默认值，当使用者没有传递具体结构时，我会出现</slot>
> 	</div>
> </template>
> 
> <script>
> 	export default {
> 		name:'Category',
> 		props:['title']
> 	}
> </script>
> 
> <style scoped>
> 	.category{
> 		background-color: skyblue;
> 		width: 200px;
> 		height: 300px;
> 	}
> 	h3{
> 		text-align: center;
> 		background-color: orange;
> 	}
> 	video{
> 		width: 100%;
> 	}
> 	img{
> 		width: 100%;
> 	}
> </style>
> 
> // 2.App.vue组件中引入Category.vue组件, 使用3次组件，分别使用不同的标签填充插槽
> <template>
> 	<div class="container">
> 		<Category title="美食" >
> 			<img src="https://s3.ax1x.com/2021/01/16/srJlq0.jpg" alt="">
> 		</Category>
> 
> 		<Category title="游戏" >
> 			<ul>
> 				<li v-for="(g,index) in games" :key="index">{{g}}</li>
> 			</ul>
> 		</Category>
> 
> 		<Category title="电影">
> 			<video controls src="http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4"></video>
> 		</Category>
> 	</div>
> </template>
> 
> <script>
> 	import Category from './components/Category'
> 	export default {
> 		name:'App',
> 		components:{Category},
> 		data() {
> 			return {
> 				foods:['火锅','烧烤','小龙虾','牛排'],
> 				games:['红色警戒','穿越火线','劲舞团','超级玛丽'],
> 				films:['《教父》','《拆弹专家》','《你好，李焕英》','《尚硅谷》']
> 			}
> 		},
> 	}
> </script>
> 
> <style scoped>
> 	.container{
> 		display: flex;
> 		justify-content: space-around;
> 	}
> </style>
> ```



> ② 具名插槽：见名知意，就是具有名字的插槽。
>
> 需求：如果有两个插槽<slot>那么想让组件标签体内传递的标签不出错，就需要使用名字，否则如果存在2个插槽的话，每个插槽的内容都是全份的组件标签体内的标签。 
>
> 使用：
>
> - 定义插槽时指定name名字；
> - 在组件标签体内的标签需要指定应用到哪个插槽：<font color="red">有两种方式</font>，如果使用<template>标签可以用专属写法。
>
> ```vue
> // 举例说明：其他省略的代码参考【默认插槽】的代码
> 
> // 1.Category.vue的片段
> <template>
> 	<div class="category">
> 		<h3>{{title}}分类</h3>
> 		<!-- 通过name指定插槽的名字 -->
> 		<slot name="center">我是一些默认值，当使用者没有传递具体结构时，我会出现1</slot>
> 		<slot name="footer">我是一些默认值，当使用者没有传递具体结构时，我会出现2</slot>
> 	</div>
> </template>
> 
> // 2.App.vue的片段
> <template>
> 	<div class="container">
> 		<Category title="美食" >
>       <!-- ① 通过在普通标签上添加【slot="插槽名字"】属性来讲标签应用到对应的插槽 -->
> 			<img slot="center" src="https://s3.ax1x.com/2021/01/16/srJlq0.jpg" alt="">
> 			<a slot="footer" href="http://www.atguigu.com">更多美食</a>
> 		</Category>
> 
> 		<Category title="游戏" >
> 			<ul slot="center">
> 				<li v-for="(g,index) in games" :key="index">{{g}}</li>
> 			</ul>
> 			<div class="foot" slot="footer">
> 				<a href="http://www.atguigu.com">单机游戏</a>
> 				<a href="http://www.atguigu.com">网络游戏</a>
> 			</div>
> 		</Category>
> 
> 		<Category title="电影">
> 			<video slot="center" controls src="http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4"></video>
>       <!-- ② 如果使用<template>则可以使用【v-slot:插槽名字】来将<template>中的结构内容应用到对应的插槽 -->
> 			<template v-slot:footer>
> 				<div class="foot">
> 					<a href="http://www.atguigu.com">经典</a>
> 					<a href="http://www.atguigu.com">热门</a>
> 					<a href="http://www.atguigu.com">推荐</a>
> 				</div>
> 				<h4>欢迎前来观影</h4>
> 			</template>
> 		</Category>
> 	</div>
> </template>
> ```



> ③ 作用域插槽：数据在组件的自身，但渲染到页面的数据结构需要组件的使用者来决定。（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）
>
> 大白话：就是插槽所在的组件内部定义了数据data，而使用插槽的父组件，
>
> 可以通过特殊属性来引用到子组件内部的数据data，看上去就是借助插槽子，组件的数据父组件可以随意使用。
>
> 注意：父组件中必须使用<template scope="变量名">， 变量名随意定义，他会包含子组件的data对象的属性。

<font color=blue style="font-size:13px;font-weight:bold">使用步骤：</font>

- 在插槽标签上传递参数，将参数传递给插槽使用者，传参方式和普通props一样，只不过这里是传给父组件的使用者，且不需要props属性接收；
- 在父组件中使用子组件的插槽传递过来的参数；

> 父组件中：
>
> ```vue
> <Category>
>   <!-- 使用属性scope拿到插槽传递的参数 -->
>   <template scope="scopeData">
>     <!-- 生成的是ul列表 -->
>     <ul>
>       <li v-for="g in scopeData.games" :key="g">{{g}}</li>
>     </ul>
>   </template>
> </Category>
> <Category>
>   <!-- 【注意】Vue 2.5 之后的版本scope属性改名为slot-scope】 -->
>   <template slot-scope="scopeData">
>     <!-- 生成的是h4标题 -->
>     <h4 v-for="g in scopeData.games" :key="g">{{g}}</h4>
>   </template>
> </Category>
> ```
>
> 子组件中：
>
> ```vue
> <template>
>     <div>
>         <slot :games="games"></slot>
>     </div>
> </template>
> <script>
>     export default {
>         name:'Category',
>         props:['title'],
>         //数据在子组件自身
>         data() {
>             return {
>                 games:['红色警戒','穿越火线','劲舞团','超级玛丽']
>             }
>         },
>     }
> </script>
> ```



### 5.Vuex：共享数据

> 定义：Vuex用于在Vue中集中式管理状态或叫管理数据，他是Vue的一个插件，即使用的时候用需要Vue.use()。
>
> 大白话：其实就是将Vue中被多数组件共用的数据，可以用Vuex管理，这样组件之间的通信就变得简单了，因为直接操作共享数据(java中可以叫共享变量)就实现了通信。
>
> 当然所谓的通信就是各个组件读取或写入在Vuex中管理的这些共享数据了。

<img src="/Users/lij/markdownWorkspace/java-leaning/resources/image-20220605120516938.png" alt="image-20220605120516938" style="zoom:33%;" align="left"/>



#### ①Vuex工作原理

<img src="/Users/lij/markdownWorkspace/java-leaning/resources/vuex.png" alt="image-20220605120516938" style="zoom:40%;" align="left"/>

> 图解：
>
> - 虚线框起来的部分是Vuex的内部结构，含3部分：【类比后端的Controller-->Service-->Dao】,[或把组件当成Controller，Vuex就是service->Dao->Database]
>
>   - Actions：可以类比struts、springmvc的控制器，实际他是一个对象，对象内部定义了很多函数，这些函数其实就是action，
>
>     每个函数都有一个key，即action的名字，用来提供给Vue组件调用时指定有哪个action处理。
>
>     可以看到虚线链接他的是一个Backend API，翻译过来就是后端API，顾名思义，这里可以ajax异步/同步调用后端接口。
>
>     进入action后会自动调用commit(参数)函数，参数中会指定交给哪个mutation处理逻辑。
>
>     [注意]：如果不需要调用后端接口或其他逻辑，其实组件可以直接调用commit来到Mutations，即跳过actions，是可以的。
>
>   - Mutationss：也是一个对象，内部封装了一些加工逻辑函数，当然它也有对应的key，方便action调用commit时指定由谁来处理。
>
>     虚线链接他的是一个Devtools，意思就是Vue的开发者工具可以监控到Mutation的操作，开发者工具就是浏览器的Vue开发工具插件。
>
>   - State：一个对象{}，他内部维护者保存在Vuex中的所有数据(就是数据处于什么状态，所以此处用了state这个关键词表示)
>
> - 虚线框以外的就是Vue的各个组件了，他通过调用dispatch(“vuex的actions的key”，”传递给actions的key对应的函数的值“)函数来指派给Vuex的actions来进行处理，
>
>   由actions调度mutations完成逻辑，最后将数据同步到state对象，在最后完成对组件的渲染。



#### ②安装Vuex与初识

> 注意：vue 2版本中只能使用vuex 3版本； vue 3版本只能使用 vuex 4版本；

```shell
// 1.安装vuex插件
npm -i vuex@3   //因为我们使用的是vue 2，所以安装vuex 3，不指定版本默认安装的是vuex4版本

// 2.使用插件：修改main.js
import Vuex from 'vuex';
Vue.use(Vuex);

// 3.创建store用来管理整个Vuex的所有组件，其实就是store就表示了Vuex
```

> <font color="red">[store需要手动创建，并定义actions、mutations、state等，创建完成后需要手动添加到Vue实例对象vm上]</font>
> <font color="red">[目录结构: 一般在src目录创建store目录，内部增加一个index.js，在此定义store对象的内容并通过es6的export导出 ]</font>
>
> <font color="red">创建store方法：</font>new Vuex.Store(options);

```shell
// 文件src/store/index.js

// 引入Vue，为了能调用Vue.use
import Vue from 'vue'
// 引入Vuex: 【在此处引入Vuex并use是因为创建Store时必须先use这个Vuex插件】
import Vuex from 'vuex'
// 应用插件: 因为index.js要引入到main.js，所以在这里使用插件也是一样的
Vue.use(Vuex);

// 准备actions——用于响应组件中的动作
const actions = {
	jiaOdd(context,value){
		console.log('actions中的jiaOdd被调用了')
		if(context.state.sum % 2){
			context.commit('JIA',value)
		}
	},
	jiaWait(context,value){
		console.log('actions中的jiaWait被调用了')
		setTimeout(()=>{
			context.commit('JIA',value)
		},500)
	}
}
// 准备mutations——用于操作数据（state）
const mutations = {
	JIA(state,value){
		console.log('mutations中的JIA被调用了')
		state.sum += value
	},
	JIAN(state,value){
		console.log('mutations中的JIAN被调用了')
		state.sum -= value
	}
}
// 准备state——用于存储数据
const state = {
	sum:0 //当前的和
}

// 创建并导出store
export default new Vuex.Store({
	actions, //这是简写方法，相当于 actions: actions
	mutations,
	state
})
```

```shell
// 4.修改main.js

// 引入Vue
import Vue from 'vue'
// 引入App
import App from './App.vue'

// 引入store：因为store目录有index.js，所以import可以省略index.js，因为默认会找index.js文件的。
import store from './store'

// 关闭Vue的生产提示
Vue.config.productionTip = false

// 创建vm
new Vue({
	el:'#app',
	render: h => h(App),
	store, // 指定使用store【此时Vue和所有VueComponent组件上都可是使用$store来操作Vuex】
	beforeCreate() {
		Vue.prototype.$bus = this
	}
})
```

```shell
// 5.使用Vuex

<template>
	<div>
		<!-- 读取Vuex的state中的数据 -->
		<h1>当前求和为：{{$store.state.sum}}</h1>
		<select v-model.number="n">
			<option value="1">1</option>
			<option value="2">2</option>
			<option value="3">3</option>
		</select>
		<button @click="increment">+</button>
		<button @click="decrement">-</button>
		<button @click="incrementOdd">当前求和为奇数再加</button>
		<button @click="incrementWait">等一等再加</button>
	</div>
</template>

<script>
	export default {
		name:'Count',
		data() {
			return {
				n:1, //用户选择的数字
			}
		},
		methods: {
			increment(){
				<!-- 直接与Mutation通信，使用commit() -->
				this.$store.commit('JIA',this.n)
			},
			decrement(){
				this.$store.commit('JIAN',this.n)
			},
			incrementOdd(){
				<!-- 与Action通信，使用dispatch() -->
				this.$store.dispatch('jiaOdd',this.n)
			},
			incrementWait(){
				this.$store.dispatch('jiaWait',this.n)
			}
		}
	}
</script>
```

#### ③Vuex的开发者工具

> 就是Vue的开发者工具，通用的，这个开发者工具就是浏览器中安装的Vue开发者工具插件。
>
> <img src="/Users/lij/markdownWorkspace/java-leaning/resources/image-20220605141727755.png" alt="image-20220605141727755" style="zoom:23%;" align="left"/>



④Store中的getters属性

> 概念：Store中存在actions、mutations、state，其实还存在一个getters属性，这个属性同样也是指定key:function
>
> 作用：当state中的数据需要经过加工后再使用时，可以使用getters加工，因为他中的function默认参数就是state对象。
>
> ```js
> // 1.在store/index.js中追加如下内容
> 
> ...
> // 定义getters对象
> const getters = {
> 	bigSum(state){ // 这是简写，等价与bigSum: function(state){return state.sum * 10;}
> 		return state.sum * 10; //需要有返回值
> 	}
> }
> 
> //创建并导出store
> export default new Vuex.Store({
> 	...,
> 	getters //增加getters到Store
> })
> 
> // 2.使用：Vue.$store.getters.bigSum
> ```